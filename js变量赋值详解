在探讨变量赋值前我们先搞清楚js的数据是如何存放在内存中的。js包含5大基本类型（string、number、boolean、null、undefined）和Object。
基础类型保存在栈内存中，Object保存在堆内存中，由一个保存在栈内存中的引用变量指向堆内存地址。

接下来探讨变量赋值，js的赋值有
1、变量初始化赋值
2、函数调用参数赋值(实参->形参)

以下面的示例进行解释：
var a = 1;
var obj = {a: 1}

var a = 1，基础类型变量赋值的分解步奏示例：
var a // 开辟栈内存存储空间，初始化赋值为undefined
a = 1 // 将变量的值赋值为1
基础类型变量赋值时的执行过程为：
1、为变量开辟栈内存空间
2、值初始化为undefined
3、为变量赋值1

var obj = {a: 1}，对象赋值分解的赋值步奏示例：
var obj // 开辟栈内存存储空间，初始化赋值为undefined
obj = {a: 1} // 将变量值（{a: 1}）放入堆内存，变量赋值为堆内存的引用地址
Object类型的变量赋值的执行过程为：
1、开辟栈内存空间
2、初始赋值为undefined
3、开辟堆内存空间
4、将变量值放入堆内存
5、变量赋值为堆内存的引用地址

上面示例的a和obj在内存中的保存情况为：
栈内存           |    堆内存
---------------
a   | 1         |
---------------
obj | 引用地址   |    {a:1}

第二种，函数调用参数赋值，实参赋值给形参。
请先记住一个结论：函数调用参数赋值是按值传递（ps:对象实参传递给形参也是按值传递，而不是按引用，原因请看下面的示例就能明白）
接下来我们讨论下为什么是按值传递。
先看个列子：
var a = 1;
var obj = {b: 2};
function demo(val, o) {
  console.log(o); // {b: 2}
  val = 11;
  o.b = 22;
  o = 33;
  console.log(val); // 11
  console.log(o); // 33
}
demo(a, obj);
console.log(a); // 1
console.log(obj); // {b:22}
obj = 2;
console.log(obj); // 2

解释：
前面的变量a,obj的赋值和堆栈情况分析省略，直接到函数demo执行阶段开始分析
a、执行demo(a, obj),进行参数赋值
  1、复制实参a的值给形参val赋值，val = 1
  2、拷贝实参obj的引用地址给值给形参o赋值，o = 引用地址
  此时的堆栈情况为：
  栈内存           |    堆内存
  -----------------------------
  a   | 1          |
  obj | 引用地址    | {b:2}
  val | 1          |
  o   | 引用地址    | 
  所以console.log(o); // 打印出 {b: 2}, obj和o都指向堆内存内的{b:2}
b、执行val = 11,此时堆栈中变为：
  栈内存           |    堆内存
  -----------------------------
  a   | 1          |
  obj | 引用地址    | {b:2}
  val | 11         |
  o   | 引用地址    | 
  所以console.log(val); // 打印出 11
c、执行 o.b = 22, o保存的是obj的引用地址，所以可以找到堆内存中的{b:2}，此时堆栈的情况为：
  栈内存           |    堆内存
  -----------------------------
  a   | 1          |
  obj | 引用地址    | {b:22}
  val | 11         |
  o   | 引用地址    | 
d、执行o = 33，o 的值被替换为33，此时堆栈情况为：
  栈内存           |    堆内存
  -----------------------------
  a   | 1          |
  obj | 引用地址    | {b:22}
  val | 11         |
  o   | 33         | 
  所以console.log(o); // 打印 33
  所以console.log(a); // 打印 1
  所以console.log(obj); // 打印 {b:22}
 e、执行obj = 2，将obj赋值为2后，堆内存里面的{b: 2}就未被任何变量引用，在GC的时候就会被删除。
  此时的堆栈情况为：
  栈内存           |    堆内存
  -----------------------------
  a   | 1          |
  obj | 2          | 
  val | 11         |
  o   | 33         | 
  所以console.log(obj); // 打印 2

其中重点要搞清楚函数调用时传递的对象参数是按值（值为对象的引用地址）传递的而不是按引用。
以上就是我所了解和理解的变量赋值的情况，如有不对，谢谢指正。
